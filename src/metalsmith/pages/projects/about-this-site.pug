---
title: "About This Site"
date: 2018-10-2
description: >
  This site was built from the ground up. From design to development. It's the biggest 
  showcase of who I am as a designer and developer. This site was a journey that has made
  me a much better developer. At this point, I'm even proud of the bugs.  
featured: false
wrapperClass: about-this-site
tags: 
  - javascript
  - scss
  - webDevelopment
thumbnail:
  image: /assets/imgs/main/mark_logo.svg
  title: Logo for Brian Hayes
  description:
---
extends ../../layouts/project.pug

block main
  article
    header.header.container
      .block.sm-12
        h1 About This Site
      
      .block.sm-12
        +titledCallout('The Intent')
          p.
            From the beginning I set out to build a website and brand that was truly 
            reflective of me as a person, a developer, and a designer. Some major changes 
            happened along the way, and through all kinds of crazy ideas and firsts, a lot
            of knowledge and experience was gained. I really tried to accomplish things in
            ways I just couldn't do for a typical client.
    section.opening.container
      .block.sm-12
        :markdown
          My goal became to write a site with no 3rd party dependencies for the deployed site. That way, I could not only show my ability to write something from scratch, but become a better developer, having dealt with many of the weird things third party libraries solve. So, while there may be a few more bugs here and there for me to flesh out and fix that I wouldn’t be dealing with had I used third party assets to support my live code, dealing with it all myself gives me a better understanding of web technologies, and gives me a better mindset to approach third party libraries with on other projects. 

          This site was originally a Jekyll powered static site slaved to a gulp task runner file, and dependent on jQuery. Since then I switched to a fully gulpjs powered development and build environment, with some help from metalsmith, and got rid of jQuery completely.
    section.major-components.container
      .block.sm-12
        :markdown
          ## Major Components of this Site:
          
          ### On The Build/Dev Side
          
          - A gulp powered build, deploy, development, and testing environment.
          - A rather strict, but readable, linting set up for JavaScript.
          - A less strict, but common-mistake-avoiding linting set up for SCSS.
          - Configuration type approach similar to Jekyll for managing the site build.
          - JavaScript unit testing environment using Mocha, Chai, and Sinon.
          - Babel to transpile ES6 to ES5 on both Javascript meant for the website, and the gulpfile.
          - More tomfoolery than I ever thought I would have to put up with from myself.
          
          ### The Site Itself
          
          - No third party dependencies! (don't know if this is the proper place for this or not?)
          - A Modular JavaScript library written to be lightweight and extrememly flexible with powerful utilities.
          - SCSS written from scratch with lots of helpful classes. Set up to be lightweight, but full featured for layouts.
          - Truly built mobile-first, with some UI modules and utilites made specifically for making mobile browsing more barable and full featured.
    section.javascript-library.container
      .block.sm-12
        :markdown
          ## My own JavaScript library
          
          I originally built the library around using jQuery, but after running into speed issues with one of the UI modules I was writing, I decided to go to just using vanilla JavaScript.
          It was pretty soon after, that I decided to start using ES6 syntax as well. Basically, the whole experience really forced me to learn a lot about JavaScript that working with libraries had me rather ignorant to.
          
          The entirety of writing a library to support my website has been a pretty crazy adventure. I really have learned so much, which sadly can be a double edged sword, because I always have the urge to completely refactor everything into a more streamlined format.
          Still, the utilities I've written alone have been worth it in the end.
          
          I think my final version of the library, conceptually, breaks down into the core, helper utilites, UI module extensions, and the UI modules themselves.
          
          ### The Core
          
          Honestly there's nothing all that new or revolutionary here. It was never meant to be much more than a way to safely expose everything beyond their individual scopes.
          
          ### Helper Utilities
          
          These modules are mostly just functions that can be used in all kinds of ways to get common tasks done. There are some classes in here as well, but mostly the insatnce is constructed on the global object literal.
          
          ### Extension Modules
          
          These might be some of my favorite, conceptually speaking. The entire idea being to construct and insatnce of the extension class in the UI module constructor, pass the element that is passed to the UI module constructor, and have a bunch of stuff done for you by the extension, while exposing some helpful new methods for the UI module.
          
          A prime example of this would be my Responsive module, which uses my Breakpoints utility module to detect which breakpoint is currently active. so basically you automatically have access to the `data-responsive` attribute on the element and can use the options passed to it to determin when the component is active.
          Thats a lot of lines of code to add to every module that needs that kind of functionality, but just construct an insatance of this extension and you have everything you need out of the box, but all the freedom in the world to impliment it as you need it.
          
          ### UI Modules
          
          I'm rather proud of some of the concepts I attempted to bring to life with my UI modules, outside of just some of the basics. While much of the power of any module in this kind of library lies in extentions, there is still plenty of room for a UI module to do some good as it is.
          The idea of UI modules in this library was to keep them independent enough that a big cross-talk infastructure would never be required. In short, this was a "get things done," kind of set up. Things have evolved a bit *(exibit A: extentions)*, but the concept remains.
          
          Probably the most "out there" module on this site is the Panes module. It's an ambitious approach to solving a lot of the big problems with mobile browsing, while making sure not to break native functionality in mobile browsers.
          The entire point of the module was to bring content in and out of the viewport and allow it to be naturally scrolled as the main document, but being able to go back to previous content and end up right where you left off.
          
          To summerize: small screen experiences doesnt have to just be things on bigger screens stacking on top of each other to create a super long page the user must endlessly scroll through.
          
          That was the goal anyway.
          
          ### Future Plans
          
          I plan on making this library a seperate entity from this website and its repository. While doing that I plan to do a lot of refactoring, and a lot of updating to the current unit tests that exist already.
          
          One of the big projects in all of this will be the Panes module, as I really think there's a lot of potential if it's made a bit more stable, nestable, and flexible.
    section.my-scss.container
      .block.sm-12
        :markdown
          ## My own SCSS 
          ### Resets
          
          While I set out to attempt writting this all without any actual reset, sanatize, or normalize dependency, I did end up having to use some resets here and there. Some things you just can't avoid.
          
          ### The grid
          
          While it’s true that, “Everyone can make a grid.” The big reason I decided to make my own flex box grid was to simply have a better understanding of what goes into doing it.
          This grid is a mixin heavy creation, that actually works pretty well in the end. I would like to experiment with a "everything is a block" type of approach and get rid of container elements all together.
          
          ### Seperationg of UI components functionality and styling.
          
          One big, more recent, effort of mine has been to seperate styles that make a UI component function, and what actually styles it into something visually pleasing.
          This really isn't the easiest of things, since I tried rather hard to keep the JavaScript scope to pure state changing, so as to allow the SCSS to do as much of the work as possible to deal with that.
          Didn't always work out, but I think it's a good way to approach things regardless.
          
          ### Animation
          
          I really wanted to focus on unique animations in my site. Things that make you go "woah" but don't get in the way too much.
          This is mostly comprised of using a lot of targeting data attributes with values that expose the current state of a component, and then trying to be clever with transition properties.
          
          The only time `@keyframe` animations were used was for the loading screen.
          
    section.gulp-pipeline.container
      .block.sm-12
        :markdown
          ## The gulp pipeline
          
          ### Config
          
          The idea of this config was inspired by how Jekyll is set up. With my set up, there's a yaml file with config options, most of which are optional, and then there's a `generate-settings.js` module that takes that config and parses it into something usable for the gulp file. This includes setting defaults if certain options arent passed.
          This module is imported into the gulp file and used throughout most of the tasks. This includes file paths, metadata for the site build, collection handling, and more. 
          
          ### Pug Templating
          
          The whole reason I ended up doing so much of my own work building this pipeline and integrating Metalsmith as a gulp task was so I could use pug as my main templating langauge. I really like the idea of being able to template with javascript, as it is so much more flexible than things like liquid.
          While there are still some limitations, I'm pretty happy with how I am able to use pug. I even set things up so I could use Front Matter in files.
          
        a(class="button" href="https://github.com/joeyred/language-fm-pug" target="_blank") I even wrote a package for Atom to allow syntax highlighting of Front Matter in pug!
        
        :markdown
          ### Unit Testing
          
          With the way thigns are set up, you can run gulp in a 100% JavaScript unit testing environment, with nothing but JavaScript for the site, unit tests, and a unit test server being active. You can also run just a development server for the site and the assets that go along with it. Finally, you can decide to run it all and have two servers running. One for unit testing, and one for the site. the watch task adapts to every situation.
          This can all be accomplished with just passing option flags to the default gulp task.
           
          ### Deployment
          
          To get the site ready to deploy, I just pass a `production` option flag to the default gulp task, and once everything is properly built, I run my special task specifically for deploying to the `gh-pages` branch of the repository.
          I will never put the actual publishing task in the pipeline that generates the distribution version of the site. I like that part being a seperate action I must take myself.
